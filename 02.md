## byte(字节)
大部分的计算机采用8位的块，byte = 8bit。
最小的可寻址内存单元，计算机在寻址的时候不是安装bit(位)进行寻址的，而是按照byte进行寻址的。

## 小端法和大端法
最低有效字节在前面的方式叫做**小端法**
最高有效字节在前面的方式叫做**大端法**
假设变量的x的类型为int,位于地址0x001的位置，十六进制的值为0x01234567。地址范围0x100~0x103的字节顺序依赖的机器的类型：
### 大端法
|0x100  | 0x0101 | 0x102 | 0x103 |
|-------|--------|-------|-------|
|01     |23      |45     |67     |
### 小端法
|0x100 |  0x101 | 0x102 |  0x103|
|------|--------|-------|-------|
|67    | 45     | 23    |  01   |

## 位运算
|符号|意思|
|--|--|
|`|`| OR|
|`&`| AND|
|`~` |NOT|
|`^`| EXCLUSIVE-OR|

## 位操作
`^` 异或操作
|  | 0110|
|--|-----|
| ^| 1100|
|  | 1010|  

## 逻辑操作
|符号 | 意思|
|-- | --|
| `||` |OR|
|`&&` |AND|
|`!`| NOT|

## 移位操作
移位操作就是的向左向右移动位模式。

## 原码，反码，补码
### 原码(true code)
对于有符号数，原码就是它的本身。
```math
[+1]_原 = 0000 0001
[-1]_原 = 1000 0001
```
### 反码(Ones' complement)
反码的表示方法：
- 正数的反码就是其本身
- 负数的反码就是在器原码的基础上，符号位不变，其余的位取反
```math
[+1] = [0000 0001]_原 = [0000 0001]_反
```
```math
[+1] = [1000 0001]_原 = [1111 1110]_反
```
### 补码(Two's complement)
- 正数的补码是其原码
- 负数的补码，在原码的基础上，符号位不变，其余各位取反，然后加1。(也就是反码+1)
```math
[+1] = [0000 0001]_原 = [0000 0001]_反 = [0000 0001]_补
```
```math
[+1] = [1000 0001]_原 = [1111 1110]_反 = [1111 1111]_补
```

## 数字溢出是如何进行处理的

// determine whether arguments can be added without overflow
对于无符号数，无符号数的位数是w，x,y，s=x+y
没有溢出的话，s>=x
当溢出的时候，s=x+y-pow(2,w),y的区间为[0~pow(2,w)-1],y < pow(2,w)
所以s=x+y-pow(2,w) < x
```c
#include<math.h>
#include<stdio.h>
// determine whether arguments can be added without overflow

int uadd_ok(unsigned x, unsigned y){
    unsigned s = x + y;

    return s < x ? 0 : 1;

}

int main(){
    unsigned x,y;
    // add ok
    x = 1;
    y = 2;

    printf("%u + %u = %u, uadd_ok=%d\n", x, y, x+y, uadd_ok(x,y) );

    // test add overflow
    y = 1;
    /*y = pow(2, size)-1;*/
    x = (unsigned)(pow(2, sizeof(unsigned)*8) - 1);
    printf("%u + %u = %u, uadd_ok=%d\n", x, y, x+y, uadd_ok(x,y) );
    return 0;
}
```

